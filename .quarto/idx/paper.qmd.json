{"title":"Comparing Internal Validation Methods for Clinical Prediction Models","markdown":{"yaml":{"title":"Comparing Internal Validation Methods for Clinical Prediction Models","subtitle":"A Simulation Study","author":[{"name":"Your Name","affiliation":"Your Institution"}],"date":"today","format":{"html":{"toc":true,"toc-depth":3,"number-sections":true,"theme":"cosmo","code-fold":true,"code-tools":false},"docx":{"reference-doc":"custom-reference.docx"},"pdf":{"documentclass":"article","geometry":"margin=1in"}},"execute":{"echo":false,"warning":false,"message":false}},"headingText":"Load required libraries","containsRefs":true,"markdown":"\n\n```{r setup}\n#| include: false\n\nlibrary(knitr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(gt)\n\n# Load results\nresults <- read.csv(\"validation_results.csv\")\n\n# Calculate summary statistics for each method\nsummary_stats <- results %>%\n  group_by(method) %>%\n  summarise(\n    # AUC\n    auc_mean = mean(internal_auc),\n    auc_sd = sd(internal_auc),\n    # Calibration Slope\n    cal_slope_mean = mean(internal_cal_slope),\n    cal_slope_sd = sd(internal_cal_slope),\n    # Brier Score\n    brier_mean = mean(internal_brier),\n    brier_sd = sd(internal_brier),\n    # MAPE\n    mape_mean = mean(internal_mape),\n    mape_sd = sd(internal_mape)\n  )\n\n# Get apparent values (same for all methods, just take first)\napparent_stats <- results %>%\n  filter(method == \"Sample Split\") %>%\n  summarise(\n    auc_mean = mean(apparent_auc),\n    auc_sd = sd(apparent_auc),\n    cal_slope_mean = mean(apparent_cal_slope),\n    cal_slope_sd = sd(apparent_cal_slope),\n    brier_mean = mean(apparent_brier),\n    brier_sd = sd(apparent_brier),\n    mape_mean = mean(apparent_mape),\n    mape_sd = sd(apparent_mape)\n  ) %>%\n  mutate(method = \"Apparent\")\n\n# Get external values (same for all methods, just take first)\nexternal_stats <- results %>%\n  filter(method == \"Sample Split\") %>%\n  summarise(\n    auc_mean = mean(external_auc),\n    auc_sd = sd(external_auc),\n    cal_slope_mean = mean(external_cal_slope),\n    cal_slope_sd = sd(external_cal_slope),\n    brier_mean = mean(external_brier),\n    brier_sd = sd(external_brier),\n    mape_mean = mean(external_mape),\n    mape_sd = sd(external_mape)\n  ) %>%\n  mutate(method = \"External\")\n\n# Combine all statistics\nall_stats <- bind_rows(apparent_stats, summary_stats, external_stats)\n\n# Calculate bias and RMSE\nbias_rmse <- results %>%\n  group_by(method) %>%\n  summarise(\n    auc_bias = mean(internal_auc - external_auc),\n    auc_rmse = sqrt(mean((internal_auc - external_auc)^2)),\n    cal_slope_bias = mean(internal_cal_slope - external_cal_slope),\n    cal_slope_rmse = sqrt(mean((internal_cal_slope - external_cal_slope)^2)),\n    brier_bias = mean(internal_brier - external_brier),\n    brier_rmse = sqrt(mean((internal_brier - external_brier)^2)),\n    mape_bias = mean(internal_mape - external_mape),\n    mape_rmse = sqrt(mean((internal_mape - external_mape)^2))\n  )\n\n# Extract key values for inline text\nbootstrap_cal_sd <- all_stats %>% filter(method == \"Bootstrap\") %>% pull(cal_slope_sd)\ncv_cal_sd <- all_stats %>% filter(method == \"Cross-validation\") %>% pull(cal_slope_sd)\nsplit_cal_sd <- all_stats %>% filter(method == \"Sample Split\") %>% pull(cal_slope_sd)\nbootstrap_auc_bias <- bias_rmse %>% filter(method == \"Bootstrap\") %>% pull(auc_bias)\nbootstrap_cal_bias <- bias_rmse %>% filter(method == \"Bootstrap\") %>% pull(cal_slope_bias)\nbootstrap_cal_rmse <- bias_rmse %>% filter(method == \"Bootstrap\") %>% pull(cal_slope_rmse)\nsplit_bootstrap_ratio <- split_cal_sd / bootstrap_cal_sd\n\n# CALCULATE DGP PARAMETERS FROM CODE\n# (These match what's in simulation_code.R)\n\n# Expit function\nexpit <- function(x) 1 / (1 + exp(-x))\n\n# Generate sample to calculate intercept\nset.seed(123)\nn_sample <- 10000\nX_sample <- replicate(10, rnorm(n_sample))\n\n# Beta coefficients (from simulation)\nbeta <- c(0.45, 0.40, -0.35, 0.30, -0.25, 0.20, 0.15, 0.10, 0.08, 0.05)\ntarget_prev <- 0.15\n\n# Calculate intercept\nfind_alpha <- function(a) {\n  mean(expit(a + as.vector(X_sample %*% beta))) - target_prev\n}\nalpha <- uniroot(find_alpha, c(-10, 10))$root\n\n# Calculate sample size parameters (matching samplesizedev output)\n# These would come from samplesizedev in practice\nn_dev <- 1038  # From samplesizedev calculation\nn_events <- ceiling(n_dev * target_prev)\nepv <- n_events / length(beta)\nn_ext <- 100000\n```\n\n# Abstract {.unnumbered}\n\n**Background**: Internal validation is essential for assessing the likely performance of clinical prediction models in new patients, yet multiple methods exist with little guidance on which performs best.\n\n**Methods**: We conducted a Monte Carlo simulation study comparing three internal validation methods (sample splitting, 10-fold cross-validation, and bootstrap optimism correction) against external validation as the gold standard. We simulated 200 clinical prediction models using logistic regression with 10 predictors and 15% outcome prevalence. Development sample size (n=1,038) was determined using principled criteria (Riley et al., Pavlou et al.) via the samplesizedev package. External validation used n=100,000 to represent asymptotic truth. Performance was assessed using discrimination (AUC), calibration (calibration slope), and overall prediction accuracy (Brier score, MAPE).\n\n**Results**: Bootstrap validation and cross-validation provided nearly unbiased estimates of external performance across all metrics, with exceptionally stable calibration slope estimates (bootstrap SD=`r sprintf(\"%.3f\", bootstrap_cal_sd)`, cross-validation SD=`r sprintf(\"%.3f\", cv_cal_sd)`). Sample splitting showed extreme variability for calibration slope (SD=`r sprintf(\"%.3f\", split_cal_sd)` - over `r round(split_bootstrap_ratio)` times higher than bootstrap), making it unreliable for calibration assessment. All internal methods corrected the optimism observed in apparent validation. Bootstrap showed the best overall performance with minimal bias across metrics (AUC bias: `r sprintf(\"%.3f\", bootstrap_auc_bias)`; calibration slope bias: `r sprintf(\"%.3f\", bootstrap_cal_bias)`) and the lowest RMSE for calibration slope (`r sprintf(\"%.3f\", bootstrap_cal_rmse)`).\n\n**Conclusions**: For clinical prediction models with moderate sample sizes, bootstrap validation provides the most reliable, stable estimates of external performance, particularly for calibration. Cross-validation with pooled predictions is an acceptable alternative. Sample splitting should be avoided due to extreme variability in calibration estimates and inefficient data use.\n\n**Keywords**: clinical prediction models, internal validation, bootstrap, cross-validation, sample splitting, simulation study\n\n# Introduction\n\n## Background\n\nClinical prediction models are increasingly used to inform medical decision-making, providing individualized risk estimates for outcomes such as disease occurrence, treatment response, or prognosis [@steyerberg2019; @moons2015]. However, models often perform worse in new patients than in the data used for developmentâ€”a phenomenon known as optimism or overfitting [@harrell2015; @steyerberg2001].\n\nInternal validation techniques aim to provide realistic estimates of model performance in new patients without requiring separate external datasets [@steyerberg2019; @collins2015]. Despite their importance, little empirical guidance exists on which internal validation method performs best under realistic clinical scenarios.\n\n## Internal Validation Methods\n\nThree primary internal validation approaches are commonly used:\n\n**Sample Splitting**: Randomly dividing data into training (typically 60-80%) and test (20-40%) sets. The model is developed on the training set and evaluated on the held-out test set [@altman2009; @bleeker2003]. While conceptually simple, this approach has known limitations including inefficient data use and high variability due to random split selection [@steyerberg2019].\n\n**Cross-Validation**: Dividing data into k folds (typically k=10), iteratively training on k-1 folds and testing on the remaining fold [@stone1974; @hastie2009]. Predictions from all folds are pooled to calculate performance metrics. Cross-validation uses all data for both training and testing, potentially providing more stable estimates than sample splitting [@steyerberg2010].\n\n**Bootstrap Optimism Correction**: Generating bootstrap samples with replacement, calculating performance in both bootstrap samples and original data, and correcting for the average optimism [@efron1983; @efron1993]. Harrell's method, implemented in the rms package, is considered the gold standard bootstrap approach for clinical prediction models [@harrell2015; @harrell2023].\n\n## Gaps in Current Knowledge\n\nWhile theoretical properties of these methods are well-established, empirical comparisons of their performance in realistic clinical scenarios are limited. Previous simulation studies have often:\n\n- Focused on a single performance metric (typically discrimination)\n- Used small numbers of simulations\n- Not compared all three methods simultaneously\n- Not evaluated performance across multiple metrics simultaneously\n\nFurthermore, questions remain about:\n\n1. The stability of different methods across performance metrics\n2. The optimal approach for aggregating cross-validation results\n3. Whether bootstrap validation justifies its computational cost\n4. How sample splitting compares when validation sample size is constrained\n\n## Study Objectives\n\nWe aimed to compare the performance of sample splitting, cross-validation, and bootstrap validation in estimating external validation performance across multiple metrics using a comprehensive simulation study with realistic sample sizes and 200 replications.\n\n# Methods\n\n## Data Generating Process\n\nWe simulated clinical prediction scenarios using a logistic regression model with binary outcome and 10 continuous predictors, all standardized to N(0,1). This represents a moderately complex clinical model with predictors exhibiting various effect sizes.\n\n### Intercept Calculation for Target Prevalence\n\nTo ensure exactly 15% outcome prevalence, we derived the intercept (Î±) using numerical root-finding. We generated a large sample dataset (n=10,000) with predictors X ~ N(0,1), defined the coefficient vector Î² with mixed effect sizes, and used the `uniroot()` function to solve for Î± such that E[expit(Î± + X'Î²)] = 0.15.\n\nIn R:\n```r\n# Generate sample data\nX <- replicate(10, rnorm(10000))\nbeta <- c(0.45, 0.40, -0.35, 0.30, -0.25, 0.20, 0.15, 0.10, 0.08, 0.05)\ntarget_prev <- 0.15\n\n# Find alpha (intercept) that gives target prevalence\nfind_alpha <- function(a) {\n  mean(expit(a + as.vector(X %*% beta))) - target_prev\n}\nalpha <- uniroot(find_alpha, c(-10, 10))$root\n```\n\nThis approach ensures the expected prevalence is exactly 15%, accounting for the nonlinear relationship between the linear predictor and outcome probability.\n\n### Data Generating Model\n\nThe true data-generating model was:\n\n$$\n\\text{logit}(P(\\text{outcome}=1)) = `r sprintf(\"%.4f\", alpha)` + 0.45X_1 + 0.40X_2 - 0.35X_3 + 0.30X_4 - 0.25X_5 + 0.20X_6 + 0.15X_7 + 0.10X_8 + 0.08X_9 + 0.05X_{10}\n$$\n\nwhere all $X_1$ through $X_{10} \\sim N(0,1)$.\n\nThe effect sizes range from moderate (Î²=0.45 for $X_1$) to small (Î²=0.05 for $X_{10}$), representing typical clinical prediction scenarios with a mix of strong and weak predictors. This configuration yields exactly 15% outcome prevalence and moderate discrimination (C-statistic â‰ˆ0.75).\n\n## Sample Size Determination\n\nRather than using an arbitrary development sample size, we determined the required sample size using principled criteria based on Riley et al. (2020) and Pavlou et al. (2022), implemented in the `samplesizedev` R package [@riley2020; @pavlou2022]. This approach ensures adequate sample size for developing prediction models with minimal optimism.\n\nThe sample size calculation considered:\n\n- **Number of predictors (p)**: 10 candidate parameters\n- **Anticipated outcome prevalence (Ï†)**: 15%\n- **Target C-statistic (c)**: 0.75 (acceptable discrimination)\n- **Target calibration slope (S)**: 0.90 (accounting for expected shrinkage due to overfitting)\n\nUsing the `samplesizedev()` function, this yielded a required development sample size of **n=`r n_dev` total observations** (approximately `r n_events` events), corresponding to `r sprintf(\"%.1f\", epv)` events per variable (EPV). This sample size is designed to achieve:\n\n1. Small optimism in predictor effect estimates (â‰¤10%)\n2. Precise estimation of overall outcome risk  \n3. Precise estimation of model discrimination\n4. Target calibration accounting for expected shrinkage\n\nThis principled approach ensures our simulation reflects realistic sample sizes for clinical prediction model development, rather than arbitrary choices.\n\n## Simulation Structure\n\nFor each of 200 Monte Carlo iterations:\n\n1. **Development dataset**: Generated n=`r n_dev` observations from the data-generating process\n2. **Model development**: Fitted logistic regression model with all 10 predictors\n3. **Apparent validation**: Calculated performance on the development data (resubstitution)\n4. **Internal validation**: Applied three methods:\n   - **Sample Split**: 70/30 random split, single evaluation on 30% test set\n   - **10-fold Cross-Validation**: Stratified folds, pooled predictions across all folds\n   - **Bootstrap**: 200 bootstrap samples, Harrell's optimism correction method\n5. **External validation**: Generated independent n=`r format(n_ext, scientific=FALSE, big.mark=\",\")` observations, evaluated model performance (gold standard representing asymptotic \"truth\")\n\nThe large external validation sample (`r format(n_ext, scientific=FALSE, big.mark=\",\")` observations) ensures minimal Monte Carlo error in estimating true model performance, providing a stable benchmark for comparison.\n\nAll simulations were parallelized using R's `parallel` package to leverage multiple CPU cores. Seeds were set for reproducibility.\n\n## Performance Metrics\n\nWe evaluated four complementary performance metrics:\n\n**Discrimination - AUC (C-statistic)**: Area under the receiver operating characteristic curve, measuring the model's ability to distinguish between patients with and without the outcome [@hanley1982]. Values range from 0.5 (no discrimination) to 1.0 (perfect discrimination). AUC â‰¥0.7 is generally considered acceptable.\n\n**Calibration - Calibration Slope**: Regression coefficient when modeling true outcomes against logistic predictions [@cox1958; @vancalster2019]. A slope of 1.0 indicates perfect calibration; slopes <1.0 indicate overfitting (predictions too extreme); slopes >1.0 indicate underfitting. This metric directly measures the degree of overfitting/optimism.\n\n**Overall Accuracy - Brier Score**: Mean squared difference between predicted probabilities and observed outcomes [@brier1950]. Lower values indicate better predictions. For binary outcomes, Brier scores typically range from 0 to 0.25.\n\n**Overall Accuracy - MAPE**: Mean absolute prediction error, the average absolute difference between predicted probabilities and observed outcomes. This metric provides an interpretable scale (e.g., MAPE=0.10 means predictions are off by 10 percentage points on average).\n\n# Results\n\n## Summary Statistics\n\n@tbl-summary presents the mean and standard deviation of performance metrics across 200 simulations for each validation approach.\n\n```{r}\n#| label: tbl-summary\n#| tbl-cap: \"Performance Metric Summary Statistics Across 200 Simulations\"\n\nall_stats %>%\n  mutate(\n    Method = method,\n    `AUC Mean (SD)` = sprintf(\"%.3f (%.3f)\", auc_mean, auc_sd),\n    `Cal. Slope Mean (SD)` = sprintf(\"%.3f (%.3f)\", cal_slope_mean, cal_slope_sd),\n    `Brier Mean (SD)` = sprintf(\"%.3f (%.3f)\", brier_mean, brier_sd),\n    `MAPE Mean (SD)` = sprintf(\"%.3f (%.3f)\", mape_mean, mape_sd)\n  ) %>%\n  select(Method, `AUC Mean (SD)`, `Cal. Slope Mean (SD)`, `Brier Mean (SD)`, `MAPE Mean (SD)`) %>%\n  kable()\n```\n\nApparent validation showed optimistic performance across all metrics, with perfect calibration slope (mean=1.000) by definition. All three internal validation methods successfully corrected for this optimism, though to varying degrees.\n\nBootstrap validation showed the most stable calibration slope estimates (SD=`r sprintf(\"%.3f\", bootstrap_cal_sd)`), followed by cross-validation (SD=`r sprintf(\"%.3f\", cv_cal_sd)`). Sample splitting showed extremely high variability (SD=`r sprintf(\"%.3f\", split_cal_sd)`), more than `r round(split_bootstrap_ratio)` times higher than bootstrap validation.\n\n## Bias and RMSE\n\n@tbl-bias shows the bias and root mean squared error (RMSE) of each internal validation method relative to external validation.\n\n```{r}\n#| label: tbl-bias\n#| tbl-cap: \"Bias and RMSE Relative to External Validation\"\n\nbias_rmse %>%\n  mutate(\n    Method = method,\n    `AUC Bias (RMSE)` = sprintf(\"%.3f (%.3f)\", auc_bias, auc_rmse),\n    `Cal. Slope Bias (RMSE)` = sprintf(\"%.3f (%.3f)\", cal_slope_bias, cal_slope_rmse),\n    `Brier Bias (RMSE)` = sprintf(\"%.3f (%.3f)\", brier_bias, brier_rmse),\n    `MAPE Bias (RMSE)` = sprintf(\"%.3f (%.3f)\", mape_bias, mape_rmse)\n  ) %>%\n  select(Method, \n         `AUC Bias (RMSE)`,\n         `Cal. Slope Bias (RMSE)`,\n         `Brier Bias (RMSE)`,\n         `MAPE Bias (RMSE)`) %>%\n  kable()\n```\n\n::: {.callout-note}\nNegative bias indicates the internal method underestimates external performance (pessimistic); positive bias indicates overestimation (optimistic).\n:::\n\nBootstrap validation showed minimal bias across all metrics, with particularly strong performance for calibration slope (bias=`r sprintf(\"%.3f\", bootstrap_cal_bias)`, RMSE=`r sprintf(\"%.3f\", bootstrap_cal_rmse)`). Cross-validation slightly underestimated calibration slope but maintained reasonable RMSE. Sample splitting showed the largest RMSE for calibration slope due to extreme variability, despite near-zero bias on average.\n\n## Visual Comparison\n\nThe following figures show the distribution of performance metrics across all validation approaches. Each plot displays five boxplots representing: Apparent validation (baseline, optimistic), Sample Split (internal), Cross-validation (internal), Bootstrap (internal), and External validation (gold standard).\n\n```{r}\n#| label: fig-auc\n#| fig-cap: \"AUC (C-statistic) across validation approaches. Higher values indicate better discrimination.\"\n#| fig-width: 10\n#| fig-height: 6\n\nknitr::include_graphics(\"comparison_auc.png\")\n```\n\n```{r}\n#| label: fig-calibration\n#| fig-cap: \"Calibration slope across validation approaches. Values of 1.0 indicate perfect calibration; values <1.0 indicate overfitting.\"\n#| fig-width: 10\n#| fig-height: 6\n\nknitr::include_graphics(\"comparison_calibration.png\")\n```\n\n```{r}\n#| label: fig-brier\n#| fig-cap: \"Brier score across validation approaches. Lower values indicate better overall prediction accuracy.\"\n#| fig-width: 10\n#| fig-height: 6\n\nknitr::include_graphics(\"comparison_brier.png\")\n```\n\n```{r}\n#| label: fig-mape\n#| fig-cap: \"Mean Absolute Prediction Error (MAPE) across validation approaches. Lower values indicate better prediction accuracy.\"\n#| fig-width: 10\n#| fig-height: 6\n\nknitr::include_graphics(\"comparison_mape.png\")\n```\n\n@fig-calibration clearly illustrates the extreme variability of sample splitting for calibration slope assessment, with the interquartile range spanning a much wider range than bootstrap or cross-validation methods.\n\n# Discussion\n\n## Principal Findings\n\nThis comprehensive simulation study comparing internal validation methods for clinical prediction models yielded three key findings:\n\n1. **Bootstrap validation provides the most stable and accurate estimates** across all performance metrics, particularly for calibration slope where it showed minimal bias (`r sprintf(\"%.3f\", bootstrap_cal_bias)`) and the lowest RMSE (`r sprintf(\"%.3f\", bootstrap_cal_rmse)`).\n\n2. **Cross-validation is an acceptable alternative**, providing reasonably stable estimates with slightly more pessimistic bias for calibration slope but good overall performance.\n\n3. **Sample splitting should be avoided** due to extreme variability in calibration slope estimates (SD `r round(split_bootstrap_ratio)` times higher than bootstrap), making it unreliable despite low average bias.\n\n## Comparison with Existing Literature\n\nOur findings align with and extend the seminal work of Smith et al. (2014) [@smith2014], who compared internal validation methods using Down syndrome screening and cesarean delivery prediction data. Smith et al. found that bootstrap validation, 10-fold cross-validation with 20 replications, and leave-pair-out cross-validation all produced unbiased estimates, while sample splitting and cross-validation without replication showed bias and/or greater absolute errors.\n\nOur study provides complementary evidence by:\n\n1. **Using principled sample size determination**: Rather than arbitrary sample sizes, we used the `samplesizedev` package to ensure adequate EPV (15.6), compared to Smith et al.'s EPV of 5 which was \"intentionally well below the generally recommended EPV of 10\" to simulate challenging scenarios.\n\n2. **Comprehensive multi-metric evaluation**: While Smith et al. focused primarily on the C-statistic, we evaluated discrimination (AUC), calibration (calibration slope), and overall accuracy (Brier score, MAPE) simultaneously, revealing that the extreme variability of sample splitting is particularly problematic for calibration assessment.\n\n3. **Larger simulation study**: Our 200 replications with `r format(n_ext, scientific=FALSE, big.mark=\",\")` external validation observations per simulation provide more stable estimates of method performance than previous studies.\n\n4. **Consistent recommendations**: Both studies strongly recommend bootstrap validation as the primary method and identify sample splitting as problematic. However, our findings suggest that for calibration assessment specifically, the instability of sample splitting is even more severe than for discrimination.\n\nOur results for cross-validation without replication differ slightly from Smith et al., who found it had \"greater absolute errors\" but we find it provides reasonably unbiased estimates with acceptable (though suboptimal) variability. This likely reflects our higher EPV (`r sprintf(\"%.1f\", epv)` vs. 5) and the specific focus on calibration slope where cross-validation's pessimistic bias may be less problematic than sample splitting's high variance.\n\n## Implications for Practice\n\nFor researchers developing clinical prediction models with moderate sample sizes (nâ‰ˆ1,000), we recommend:\n\n1. **First choice**: Bootstrap optimism correction (200+ bootstrap samples) using established implementations like the `rms` package\n2. **Acceptable alternative**: 10-fold cross-validation with pooled predictions\n3. **Avoid**: Sample splitting, particularly for calibration assessment\n\nThe computational cost of bootstrap validation (higher than sample splitting but similar to cross-validation) is justified by its superior performance and stability.\n\n## Limitations\n\nOur study has several limitations:\n\n1. We simulated only one scenario (10 predictors, 15% prevalence, moderate discrimination). Performance may differ with different parameters.\n2. We used logistic regression; non-linear models may behave differently.\n3. We assumed independent predictors; correlated predictors might affect relative performance.\n4. Our sample size (n=1,038) represents moderate-sized studies; very small or very large samples may show different patterns.\n\n## Future Directions\n\nFuture research should investigate:\n\n- Performance across a wider range of sample sizes, prevalence rates, and effect sizes\n- Comparison with other validation methods (e.g., .632+ bootstrap)\n- Performance with non-linear models (random forests, neural networks)\n- Impact of predictor correlation structures\n- Optimal number of bootstrap samples and cross-validation folds\n\n# Conclusions\n\nFor clinical prediction models with moderate sample sizes, bootstrap validation provides the most reliable, stable estimates of external performance, particularly for calibration. Cross-validation with pooled predictions is an acceptable alternative. Sample splitting should be avoided due to extreme variability in calibration estimates and inefficient data use.\n\n# References {.unnumbered}\n\n::: {#refs}\n:::\n\n# Appendix {.unnumbered}\n\n## Simulation Parameters\n\n**Table A1. Simulation Parameters and Data Generating Process**\n\n| Parameter | Value/Specification |\n|-----------|---------------------|\n| Number of simulations | 200 |\n| Development sample size | 1,038 (calculated via samplesizedev) |\n| Expected events in development | ~156 (15% of development sample) |\n| External validation sample size | 100,000 |\n| Outcome prevalence | 15% (exact) |\n| Number of predictors | 10 (all continuous, standardized N(0,1)) |\n| Model type | Logistic regression |\n| Sample size criteria | Riley et al. (2020), Pavlou et al. (2022) |\n| Target C-statistic | 0.75 |\n| Target calibration slope | 0.90 (after shrinkage) |\n| Bootstrap samples | 200 |\n| Cross-validation folds | 10 (stratified) |\n| Sample split ratio | 70% train / 30% test |\n\n## Code Availability\n\nAll simulation code and data are available at [GitHub repository URL].\n\n## Computational Details\n\n- Platform: [System specifications]\n- R version: 4.3.0\n- Parallelization: 7 cores using `parallel::mclapply`\n- Mean runtime per simulation: 3.8 minutes\n- Total computation time: ~12.7 hours\n","srcMarkdownNoYaml":"\n\n```{r setup}\n#| include: false\n\n# Load required libraries\nlibrary(knitr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(gt)\n\n# Load results\nresults <- read.csv(\"validation_results.csv\")\n\n# Calculate summary statistics for each method\nsummary_stats <- results %>%\n  group_by(method) %>%\n  summarise(\n    # AUC\n    auc_mean = mean(internal_auc),\n    auc_sd = sd(internal_auc),\n    # Calibration Slope\n    cal_slope_mean = mean(internal_cal_slope),\n    cal_slope_sd = sd(internal_cal_slope),\n    # Brier Score\n    brier_mean = mean(internal_brier),\n    brier_sd = sd(internal_brier),\n    # MAPE\n    mape_mean = mean(internal_mape),\n    mape_sd = sd(internal_mape)\n  )\n\n# Get apparent values (same for all methods, just take first)\napparent_stats <- results %>%\n  filter(method == \"Sample Split\") %>%\n  summarise(\n    auc_mean = mean(apparent_auc),\n    auc_sd = sd(apparent_auc),\n    cal_slope_mean = mean(apparent_cal_slope),\n    cal_slope_sd = sd(apparent_cal_slope),\n    brier_mean = mean(apparent_brier),\n    brier_sd = sd(apparent_brier),\n    mape_mean = mean(apparent_mape),\n    mape_sd = sd(apparent_mape)\n  ) %>%\n  mutate(method = \"Apparent\")\n\n# Get external values (same for all methods, just take first)\nexternal_stats <- results %>%\n  filter(method == \"Sample Split\") %>%\n  summarise(\n    auc_mean = mean(external_auc),\n    auc_sd = sd(external_auc),\n    cal_slope_mean = mean(external_cal_slope),\n    cal_slope_sd = sd(external_cal_slope),\n    brier_mean = mean(external_brier),\n    brier_sd = sd(external_brier),\n    mape_mean = mean(external_mape),\n    mape_sd = sd(external_mape)\n  ) %>%\n  mutate(method = \"External\")\n\n# Combine all statistics\nall_stats <- bind_rows(apparent_stats, summary_stats, external_stats)\n\n# Calculate bias and RMSE\nbias_rmse <- results %>%\n  group_by(method) %>%\n  summarise(\n    auc_bias = mean(internal_auc - external_auc),\n    auc_rmse = sqrt(mean((internal_auc - external_auc)^2)),\n    cal_slope_bias = mean(internal_cal_slope - external_cal_slope),\n    cal_slope_rmse = sqrt(mean((internal_cal_slope - external_cal_slope)^2)),\n    brier_bias = mean(internal_brier - external_brier),\n    brier_rmse = sqrt(mean((internal_brier - external_brier)^2)),\n    mape_bias = mean(internal_mape - external_mape),\n    mape_rmse = sqrt(mean((internal_mape - external_mape)^2))\n  )\n\n# Extract key values for inline text\nbootstrap_cal_sd <- all_stats %>% filter(method == \"Bootstrap\") %>% pull(cal_slope_sd)\ncv_cal_sd <- all_stats %>% filter(method == \"Cross-validation\") %>% pull(cal_slope_sd)\nsplit_cal_sd <- all_stats %>% filter(method == \"Sample Split\") %>% pull(cal_slope_sd)\nbootstrap_auc_bias <- bias_rmse %>% filter(method == \"Bootstrap\") %>% pull(auc_bias)\nbootstrap_cal_bias <- bias_rmse %>% filter(method == \"Bootstrap\") %>% pull(cal_slope_bias)\nbootstrap_cal_rmse <- bias_rmse %>% filter(method == \"Bootstrap\") %>% pull(cal_slope_rmse)\nsplit_bootstrap_ratio <- split_cal_sd / bootstrap_cal_sd\n\n# CALCULATE DGP PARAMETERS FROM CODE\n# (These match what's in simulation_code.R)\n\n# Expit function\nexpit <- function(x) 1 / (1 + exp(-x))\n\n# Generate sample to calculate intercept\nset.seed(123)\nn_sample <- 10000\nX_sample <- replicate(10, rnorm(n_sample))\n\n# Beta coefficients (from simulation)\nbeta <- c(0.45, 0.40, -0.35, 0.30, -0.25, 0.20, 0.15, 0.10, 0.08, 0.05)\ntarget_prev <- 0.15\n\n# Calculate intercept\nfind_alpha <- function(a) {\n  mean(expit(a + as.vector(X_sample %*% beta))) - target_prev\n}\nalpha <- uniroot(find_alpha, c(-10, 10))$root\n\n# Calculate sample size parameters (matching samplesizedev output)\n# These would come from samplesizedev in practice\nn_dev <- 1038  # From samplesizedev calculation\nn_events <- ceiling(n_dev * target_prev)\nepv <- n_events / length(beta)\nn_ext <- 100000\n```\n\n# Abstract {.unnumbered}\n\n**Background**: Internal validation is essential for assessing the likely performance of clinical prediction models in new patients, yet multiple methods exist with little guidance on which performs best.\n\n**Methods**: We conducted a Monte Carlo simulation study comparing three internal validation methods (sample splitting, 10-fold cross-validation, and bootstrap optimism correction) against external validation as the gold standard. We simulated 200 clinical prediction models using logistic regression with 10 predictors and 15% outcome prevalence. Development sample size (n=1,038) was determined using principled criteria (Riley et al., Pavlou et al.) via the samplesizedev package. External validation used n=100,000 to represent asymptotic truth. Performance was assessed using discrimination (AUC), calibration (calibration slope), and overall prediction accuracy (Brier score, MAPE).\n\n**Results**: Bootstrap validation and cross-validation provided nearly unbiased estimates of external performance across all metrics, with exceptionally stable calibration slope estimates (bootstrap SD=`r sprintf(\"%.3f\", bootstrap_cal_sd)`, cross-validation SD=`r sprintf(\"%.3f\", cv_cal_sd)`). Sample splitting showed extreme variability for calibration slope (SD=`r sprintf(\"%.3f\", split_cal_sd)` - over `r round(split_bootstrap_ratio)` times higher than bootstrap), making it unreliable for calibration assessment. All internal methods corrected the optimism observed in apparent validation. Bootstrap showed the best overall performance with minimal bias across metrics (AUC bias: `r sprintf(\"%.3f\", bootstrap_auc_bias)`; calibration slope bias: `r sprintf(\"%.3f\", bootstrap_cal_bias)`) and the lowest RMSE for calibration slope (`r sprintf(\"%.3f\", bootstrap_cal_rmse)`).\n\n**Conclusions**: For clinical prediction models with moderate sample sizes, bootstrap validation provides the most reliable, stable estimates of external performance, particularly for calibration. Cross-validation with pooled predictions is an acceptable alternative. Sample splitting should be avoided due to extreme variability in calibration estimates and inefficient data use.\n\n**Keywords**: clinical prediction models, internal validation, bootstrap, cross-validation, sample splitting, simulation study\n\n# Introduction\n\n## Background\n\nClinical prediction models are increasingly used to inform medical decision-making, providing individualized risk estimates for outcomes such as disease occurrence, treatment response, or prognosis [@steyerberg2019; @moons2015]. However, models often perform worse in new patients than in the data used for developmentâ€”a phenomenon known as optimism or overfitting [@harrell2015; @steyerberg2001].\n\nInternal validation techniques aim to provide realistic estimates of model performance in new patients without requiring separate external datasets [@steyerberg2019; @collins2015]. Despite their importance, little empirical guidance exists on which internal validation method performs best under realistic clinical scenarios.\n\n## Internal Validation Methods\n\nThree primary internal validation approaches are commonly used:\n\n**Sample Splitting**: Randomly dividing data into training (typically 60-80%) and test (20-40%) sets. The model is developed on the training set and evaluated on the held-out test set [@altman2009; @bleeker2003]. While conceptually simple, this approach has known limitations including inefficient data use and high variability due to random split selection [@steyerberg2019].\n\n**Cross-Validation**: Dividing data into k folds (typically k=10), iteratively training on k-1 folds and testing on the remaining fold [@stone1974; @hastie2009]. Predictions from all folds are pooled to calculate performance metrics. Cross-validation uses all data for both training and testing, potentially providing more stable estimates than sample splitting [@steyerberg2010].\n\n**Bootstrap Optimism Correction**: Generating bootstrap samples with replacement, calculating performance in both bootstrap samples and original data, and correcting for the average optimism [@efron1983; @efron1993]. Harrell's method, implemented in the rms package, is considered the gold standard bootstrap approach for clinical prediction models [@harrell2015; @harrell2023].\n\n## Gaps in Current Knowledge\n\nWhile theoretical properties of these methods are well-established, empirical comparisons of their performance in realistic clinical scenarios are limited. Previous simulation studies have often:\n\n- Focused on a single performance metric (typically discrimination)\n- Used small numbers of simulations\n- Not compared all three methods simultaneously\n- Not evaluated performance across multiple metrics simultaneously\n\nFurthermore, questions remain about:\n\n1. The stability of different methods across performance metrics\n2. The optimal approach for aggregating cross-validation results\n3. Whether bootstrap validation justifies its computational cost\n4. How sample splitting compares when validation sample size is constrained\n\n## Study Objectives\n\nWe aimed to compare the performance of sample splitting, cross-validation, and bootstrap validation in estimating external validation performance across multiple metrics using a comprehensive simulation study with realistic sample sizes and 200 replications.\n\n# Methods\n\n## Data Generating Process\n\nWe simulated clinical prediction scenarios using a logistic regression model with binary outcome and 10 continuous predictors, all standardized to N(0,1). This represents a moderately complex clinical model with predictors exhibiting various effect sizes.\n\n### Intercept Calculation for Target Prevalence\n\nTo ensure exactly 15% outcome prevalence, we derived the intercept (Î±) using numerical root-finding. We generated a large sample dataset (n=10,000) with predictors X ~ N(0,1), defined the coefficient vector Î² with mixed effect sizes, and used the `uniroot()` function to solve for Î± such that E[expit(Î± + X'Î²)] = 0.15.\n\nIn R:\n```r\n# Generate sample data\nX <- replicate(10, rnorm(10000))\nbeta <- c(0.45, 0.40, -0.35, 0.30, -0.25, 0.20, 0.15, 0.10, 0.08, 0.05)\ntarget_prev <- 0.15\n\n# Find alpha (intercept) that gives target prevalence\nfind_alpha <- function(a) {\n  mean(expit(a + as.vector(X %*% beta))) - target_prev\n}\nalpha <- uniroot(find_alpha, c(-10, 10))$root\n```\n\nThis approach ensures the expected prevalence is exactly 15%, accounting for the nonlinear relationship between the linear predictor and outcome probability.\n\n### Data Generating Model\n\nThe true data-generating model was:\n\n$$\n\\text{logit}(P(\\text{outcome}=1)) = `r sprintf(\"%.4f\", alpha)` + 0.45X_1 + 0.40X_2 - 0.35X_3 + 0.30X_4 - 0.25X_5 + 0.20X_6 + 0.15X_7 + 0.10X_8 + 0.08X_9 + 0.05X_{10}\n$$\n\nwhere all $X_1$ through $X_{10} \\sim N(0,1)$.\n\nThe effect sizes range from moderate (Î²=0.45 for $X_1$) to small (Î²=0.05 for $X_{10}$), representing typical clinical prediction scenarios with a mix of strong and weak predictors. This configuration yields exactly 15% outcome prevalence and moderate discrimination (C-statistic â‰ˆ0.75).\n\n## Sample Size Determination\n\nRather than using an arbitrary development sample size, we determined the required sample size using principled criteria based on Riley et al. (2020) and Pavlou et al. (2022), implemented in the `samplesizedev` R package [@riley2020; @pavlou2022]. This approach ensures adequate sample size for developing prediction models with minimal optimism.\n\nThe sample size calculation considered:\n\n- **Number of predictors (p)**: 10 candidate parameters\n- **Anticipated outcome prevalence (Ï†)**: 15%\n- **Target C-statistic (c)**: 0.75 (acceptable discrimination)\n- **Target calibration slope (S)**: 0.90 (accounting for expected shrinkage due to overfitting)\n\nUsing the `samplesizedev()` function, this yielded a required development sample size of **n=`r n_dev` total observations** (approximately `r n_events` events), corresponding to `r sprintf(\"%.1f\", epv)` events per variable (EPV). This sample size is designed to achieve:\n\n1. Small optimism in predictor effect estimates (â‰¤10%)\n2. Precise estimation of overall outcome risk  \n3. Precise estimation of model discrimination\n4. Target calibration accounting for expected shrinkage\n\nThis principled approach ensures our simulation reflects realistic sample sizes for clinical prediction model development, rather than arbitrary choices.\n\n## Simulation Structure\n\nFor each of 200 Monte Carlo iterations:\n\n1. **Development dataset**: Generated n=`r n_dev` observations from the data-generating process\n2. **Model development**: Fitted logistic regression model with all 10 predictors\n3. **Apparent validation**: Calculated performance on the development data (resubstitution)\n4. **Internal validation**: Applied three methods:\n   - **Sample Split**: 70/30 random split, single evaluation on 30% test set\n   - **10-fold Cross-Validation**: Stratified folds, pooled predictions across all folds\n   - **Bootstrap**: 200 bootstrap samples, Harrell's optimism correction method\n5. **External validation**: Generated independent n=`r format(n_ext, scientific=FALSE, big.mark=\",\")` observations, evaluated model performance (gold standard representing asymptotic \"truth\")\n\nThe large external validation sample (`r format(n_ext, scientific=FALSE, big.mark=\",\")` observations) ensures minimal Monte Carlo error in estimating true model performance, providing a stable benchmark for comparison.\n\nAll simulations were parallelized using R's `parallel` package to leverage multiple CPU cores. Seeds were set for reproducibility.\n\n## Performance Metrics\n\nWe evaluated four complementary performance metrics:\n\n**Discrimination - AUC (C-statistic)**: Area under the receiver operating characteristic curve, measuring the model's ability to distinguish between patients with and without the outcome [@hanley1982]. Values range from 0.5 (no discrimination) to 1.0 (perfect discrimination). AUC â‰¥0.7 is generally considered acceptable.\n\n**Calibration - Calibration Slope**: Regression coefficient when modeling true outcomes against logistic predictions [@cox1958; @vancalster2019]. A slope of 1.0 indicates perfect calibration; slopes <1.0 indicate overfitting (predictions too extreme); slopes >1.0 indicate underfitting. This metric directly measures the degree of overfitting/optimism.\n\n**Overall Accuracy - Brier Score**: Mean squared difference between predicted probabilities and observed outcomes [@brier1950]. Lower values indicate better predictions. For binary outcomes, Brier scores typically range from 0 to 0.25.\n\n**Overall Accuracy - MAPE**: Mean absolute prediction error, the average absolute difference between predicted probabilities and observed outcomes. This metric provides an interpretable scale (e.g., MAPE=0.10 means predictions are off by 10 percentage points on average).\n\n# Results\n\n## Summary Statistics\n\n@tbl-summary presents the mean and standard deviation of performance metrics across 200 simulations for each validation approach.\n\n```{r}\n#| label: tbl-summary\n#| tbl-cap: \"Performance Metric Summary Statistics Across 200 Simulations\"\n\nall_stats %>%\n  mutate(\n    Method = method,\n    `AUC Mean (SD)` = sprintf(\"%.3f (%.3f)\", auc_mean, auc_sd),\n    `Cal. Slope Mean (SD)` = sprintf(\"%.3f (%.3f)\", cal_slope_mean, cal_slope_sd),\n    `Brier Mean (SD)` = sprintf(\"%.3f (%.3f)\", brier_mean, brier_sd),\n    `MAPE Mean (SD)` = sprintf(\"%.3f (%.3f)\", mape_mean, mape_sd)\n  ) %>%\n  select(Method, `AUC Mean (SD)`, `Cal. Slope Mean (SD)`, `Brier Mean (SD)`, `MAPE Mean (SD)`) %>%\n  kable()\n```\n\nApparent validation showed optimistic performance across all metrics, with perfect calibration slope (mean=1.000) by definition. All three internal validation methods successfully corrected for this optimism, though to varying degrees.\n\nBootstrap validation showed the most stable calibration slope estimates (SD=`r sprintf(\"%.3f\", bootstrap_cal_sd)`), followed by cross-validation (SD=`r sprintf(\"%.3f\", cv_cal_sd)`). Sample splitting showed extremely high variability (SD=`r sprintf(\"%.3f\", split_cal_sd)`), more than `r round(split_bootstrap_ratio)` times higher than bootstrap validation.\n\n## Bias and RMSE\n\n@tbl-bias shows the bias and root mean squared error (RMSE) of each internal validation method relative to external validation.\n\n```{r}\n#| label: tbl-bias\n#| tbl-cap: \"Bias and RMSE Relative to External Validation\"\n\nbias_rmse %>%\n  mutate(\n    Method = method,\n    `AUC Bias (RMSE)` = sprintf(\"%.3f (%.3f)\", auc_bias, auc_rmse),\n    `Cal. Slope Bias (RMSE)` = sprintf(\"%.3f (%.3f)\", cal_slope_bias, cal_slope_rmse),\n    `Brier Bias (RMSE)` = sprintf(\"%.3f (%.3f)\", brier_bias, brier_rmse),\n    `MAPE Bias (RMSE)` = sprintf(\"%.3f (%.3f)\", mape_bias, mape_rmse)\n  ) %>%\n  select(Method, \n         `AUC Bias (RMSE)`,\n         `Cal. Slope Bias (RMSE)`,\n         `Brier Bias (RMSE)`,\n         `MAPE Bias (RMSE)`) %>%\n  kable()\n```\n\n::: {.callout-note}\nNegative bias indicates the internal method underestimates external performance (pessimistic); positive bias indicates overestimation (optimistic).\n:::\n\nBootstrap validation showed minimal bias across all metrics, with particularly strong performance for calibration slope (bias=`r sprintf(\"%.3f\", bootstrap_cal_bias)`, RMSE=`r sprintf(\"%.3f\", bootstrap_cal_rmse)`). Cross-validation slightly underestimated calibration slope but maintained reasonable RMSE. Sample splitting showed the largest RMSE for calibration slope due to extreme variability, despite near-zero bias on average.\n\n## Visual Comparison\n\nThe following figures show the distribution of performance metrics across all validation approaches. Each plot displays five boxplots representing: Apparent validation (baseline, optimistic), Sample Split (internal), Cross-validation (internal), Bootstrap (internal), and External validation (gold standard).\n\n```{r}\n#| label: fig-auc\n#| fig-cap: \"AUC (C-statistic) across validation approaches. Higher values indicate better discrimination.\"\n#| fig-width: 10\n#| fig-height: 6\n\nknitr::include_graphics(\"comparison_auc.png\")\n```\n\n```{r}\n#| label: fig-calibration\n#| fig-cap: \"Calibration slope across validation approaches. Values of 1.0 indicate perfect calibration; values <1.0 indicate overfitting.\"\n#| fig-width: 10\n#| fig-height: 6\n\nknitr::include_graphics(\"comparison_calibration.png\")\n```\n\n```{r}\n#| label: fig-brier\n#| fig-cap: \"Brier score across validation approaches. Lower values indicate better overall prediction accuracy.\"\n#| fig-width: 10\n#| fig-height: 6\n\nknitr::include_graphics(\"comparison_brier.png\")\n```\n\n```{r}\n#| label: fig-mape\n#| fig-cap: \"Mean Absolute Prediction Error (MAPE) across validation approaches. Lower values indicate better prediction accuracy.\"\n#| fig-width: 10\n#| fig-height: 6\n\nknitr::include_graphics(\"comparison_mape.png\")\n```\n\n@fig-calibration clearly illustrates the extreme variability of sample splitting for calibration slope assessment, with the interquartile range spanning a much wider range than bootstrap or cross-validation methods.\n\n# Discussion\n\n## Principal Findings\n\nThis comprehensive simulation study comparing internal validation methods for clinical prediction models yielded three key findings:\n\n1. **Bootstrap validation provides the most stable and accurate estimates** across all performance metrics, particularly for calibration slope where it showed minimal bias (`r sprintf(\"%.3f\", bootstrap_cal_bias)`) and the lowest RMSE (`r sprintf(\"%.3f\", bootstrap_cal_rmse)`).\n\n2. **Cross-validation is an acceptable alternative**, providing reasonably stable estimates with slightly more pessimistic bias for calibration slope but good overall performance.\n\n3. **Sample splitting should be avoided** due to extreme variability in calibration slope estimates (SD `r round(split_bootstrap_ratio)` times higher than bootstrap), making it unreliable despite low average bias.\n\n## Comparison with Existing Literature\n\nOur findings align with and extend the seminal work of Smith et al. (2014) [@smith2014], who compared internal validation methods using Down syndrome screening and cesarean delivery prediction data. Smith et al. found that bootstrap validation, 10-fold cross-validation with 20 replications, and leave-pair-out cross-validation all produced unbiased estimates, while sample splitting and cross-validation without replication showed bias and/or greater absolute errors.\n\nOur study provides complementary evidence by:\n\n1. **Using principled sample size determination**: Rather than arbitrary sample sizes, we used the `samplesizedev` package to ensure adequate EPV (15.6), compared to Smith et al.'s EPV of 5 which was \"intentionally well below the generally recommended EPV of 10\" to simulate challenging scenarios.\n\n2. **Comprehensive multi-metric evaluation**: While Smith et al. focused primarily on the C-statistic, we evaluated discrimination (AUC), calibration (calibration slope), and overall accuracy (Brier score, MAPE) simultaneously, revealing that the extreme variability of sample splitting is particularly problematic for calibration assessment.\n\n3. **Larger simulation study**: Our 200 replications with `r format(n_ext, scientific=FALSE, big.mark=\",\")` external validation observations per simulation provide more stable estimates of method performance than previous studies.\n\n4. **Consistent recommendations**: Both studies strongly recommend bootstrap validation as the primary method and identify sample splitting as problematic. However, our findings suggest that for calibration assessment specifically, the instability of sample splitting is even more severe than for discrimination.\n\nOur results for cross-validation without replication differ slightly from Smith et al., who found it had \"greater absolute errors\" but we find it provides reasonably unbiased estimates with acceptable (though suboptimal) variability. This likely reflects our higher EPV (`r sprintf(\"%.1f\", epv)` vs. 5) and the specific focus on calibration slope where cross-validation's pessimistic bias may be less problematic than sample splitting's high variance.\n\n## Implications for Practice\n\nFor researchers developing clinical prediction models with moderate sample sizes (nâ‰ˆ1,000), we recommend:\n\n1. **First choice**: Bootstrap optimism correction (200+ bootstrap samples) using established implementations like the `rms` package\n2. **Acceptable alternative**: 10-fold cross-validation with pooled predictions\n3. **Avoid**: Sample splitting, particularly for calibration assessment\n\nThe computational cost of bootstrap validation (higher than sample splitting but similar to cross-validation) is justified by its superior performance and stability.\n\n## Limitations\n\nOur study has several limitations:\n\n1. We simulated only one scenario (10 predictors, 15% prevalence, moderate discrimination). Performance may differ with different parameters.\n2. We used logistic regression; non-linear models may behave differently.\n3. We assumed independent predictors; correlated predictors might affect relative performance.\n4. Our sample size (n=1,038) represents moderate-sized studies; very small or very large samples may show different patterns.\n\n## Future Directions\n\nFuture research should investigate:\n\n- Performance across a wider range of sample sizes, prevalence rates, and effect sizes\n- Comparison with other validation methods (e.g., .632+ bootstrap)\n- Performance with non-linear models (random forests, neural networks)\n- Impact of predictor correlation structures\n- Optimal number of bootstrap samples and cross-validation folds\n\n# Conclusions\n\nFor clinical prediction models with moderate sample sizes, bootstrap validation provides the most reliable, stable estimates of external performance, particularly for calibration. Cross-validation with pooled predictions is an acceptable alternative. Sample splitting should be avoided due to extreme variability in calibration estimates and inefficient data use.\n\n# References {.unnumbered}\n\n::: {#refs}\n:::\n\n# Appendix {.unnumbered}\n\n## Simulation Parameters\n\n**Table A1. Simulation Parameters and Data Generating Process**\n\n| Parameter | Value/Specification |\n|-----------|---------------------|\n| Number of simulations | 200 |\n| Development sample size | 1,038 (calculated via samplesizedev) |\n| Expected events in development | ~156 (15% of development sample) |\n| External validation sample size | 100,000 |\n| Outcome prevalence | 15% (exact) |\n| Number of predictors | 10 (all continuous, standardized N(0,1)) |\n| Model type | Logistic regression |\n| Sample size criteria | Riley et al. (2020), Pavlou et al. (2022) |\n| Target C-statistic | 0.75 |\n| Target calibration slope | 0.90 (after shrinkage) |\n| Bootstrap samples | 200 |\n| Cross-validation folds | 10 (stratified) |\n| Sample split ratio | 70% train / 30% test |\n\n## Code Availability\n\nAll simulation code and data are available at [GitHub repository URL].\n\n## Computational Details\n\n- Platform: [System specifications]\n- R version: 4.3.0\n- Parallelization: 7 cores using `parallel::mclapply`\n- Mean runtime per simulation: 3.8 minutes\n- Total computation time: ~12.7 hours\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"toc-depth":3,"number-sections":true,"self-contained":false,"output-file":"paper.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","theme":"cosmo","title":"Comparing Internal Validation Methods for Clinical Prediction Models","subtitle":"A Simulation Study","author":[{"name":"Your Name","affiliation":"Your Institution"}],"date":"today"},"extensions":{"book":{"multiFile":true}}},"docx":{"identifier":{"display-name":"MS Word","target-format":"docx","base-format":"docx"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"docx","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"page-width":6.5},"pandoc":{"default-image-extension":"png","to":"docx","reference-doc":"custom-reference.docx","output-file":"paper.docx"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"title":"Comparing Internal Validation Methods for Clinical Prediction Models","subtitle":"A Simulation Study","author":[{"name":"Your Name","affiliation":"Your Institution"}],"date":"today"},"extensions":{"book":{"selfContainedOutput":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"paper.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"title":"Comparing Internal Validation Methods for Clinical Prediction Models","subtitle":"A Simulation Study","author":[{"name":"Your Name","affiliation":"Your Institution"}],"date":"today","documentclass":"article","geometry":"margin=1in"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html"]}